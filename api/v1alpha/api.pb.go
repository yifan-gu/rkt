// Code generated by protoc-gen-go.
// source: api.proto
// DO NOT EDIT!

/*
Package v1alpha is a generated protocol buffer package.

It is generated from these files:
	api.proto

It has these top-level messages:
	FetchImageRequest
	FetchImageResponse
	PreparePodRequest
	PreparePodResponse
	RemovePodRequest
	RemovePodResponse
	RemoveImageRequest
	RemoveImageResponse
	EnterPodRequest
	EnterPodResponse
	ImageFormat
	Image
	Network
	App
	Pod
	KeyValue
	PodFilter
	ImageFilter
	GlobalFlags
	Info
	Event
	EventFilter
	GetInfoRequest
	GetInfoResponse
	ListPodsRequest
	ListPodsResponse
	InspectPodRequest
	InspectPodResponse
	ListImagesRequest
	ListImagesResponse
	InspectImageRequest
	InspectImageResponse
	ListenEventsRequest
	ListenEventsResponse
	GetLogsRequest
	GetLogsResponse
*/
package v1alpha

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// ImageType defines the supported image type.
type ImageType int32

const (
	ImageType_IMAGE_TYPE_UNDEFINED ImageType = 0
	ImageType_IMAGE_TYPE_APPC      ImageType = 1
	ImageType_IMAGE_TYPE_DOCKER    ImageType = 2
	ImageType_IMAGE_TYPE_OCI       ImageType = 3
)

var ImageType_name = map[int32]string{
	0: "IMAGE_TYPE_UNDEFINED",
	1: "IMAGE_TYPE_APPC",
	2: "IMAGE_TYPE_DOCKER",
	3: "IMAGE_TYPE_OCI",
}
var ImageType_value = map[string]int32{
	"IMAGE_TYPE_UNDEFINED": 0,
	"IMAGE_TYPE_APPC":      1,
	"IMAGE_TYPE_DOCKER":    2,
	"IMAGE_TYPE_OCI":       3,
}

func (x ImageType) String() string {
	return proto.EnumName(ImageType_name, int32(x))
}
func (ImageType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// InsecureOption defines the insecure option flags to be used.
type InsecureOption int32

const (
	InsecureOption_INSECURE_OPTION_NONE    InsecureOption = 0
	InsecureOption_INSECURE_OPTION_ALL     InsecureOption = 1
	InsecureOption_INSECURE_OPTION_IMAGE   InsecureOption = 2
	InsecureOption_INSECURE_OPTION_TLS     InsecureOption = 4
	InsecureOption_INSECURE_OPTION_ON_DISK InsecureOption = 8
	InsecureOption_INSECURE_OPTION_HTTP    InsecureOption = 16
	InsecureOption_INSECURE_OPTION_PUBKEY  InsecureOption = 32
)

var InsecureOption_name = map[int32]string{
	0:  "INSECURE_OPTION_NONE",
	1:  "INSECURE_OPTION_ALL",
	2:  "INSECURE_OPTION_IMAGE",
	4:  "INSECURE_OPTION_TLS",
	8:  "INSECURE_OPTION_ON_DISK",
	16: "INSECURE_OPTION_HTTP",
	32: "INSECURE_OPTION_PUBKEY",
}
var InsecureOption_value = map[string]int32{
	"INSECURE_OPTION_NONE":    0,
	"INSECURE_OPTION_ALL":     1,
	"INSECURE_OPTION_IMAGE":   2,
	"INSECURE_OPTION_TLS":     4,
	"INSECURE_OPTION_ON_DISK": 8,
	"INSECURE_OPTION_HTTP":    16,
	"INSECURE_OPTION_PUBKEY":  32,
}

func (x InsecureOption) String() string {
	return proto.EnumName(InsecureOption_name, int32(x))
}
func (InsecureOption) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// DiscoverOption defines the discovery options to be used for fetching.
type DiscoverOption int32

const (
	DiscoverOption_DISCOVER_OPTION_NONE       DiscoverOption = 0
	DiscoverOption_DISCOVER_OPTION_NO_STORE   DiscoverOption = 1
	DiscoverOption_DISCOVER_OPTION_ONLY_STORE DiscoverOption = 2
)

var DiscoverOption_name = map[int32]string{
	0: "DISCOVER_OPTION_NONE",
	1: "DISCOVER_OPTION_NO_STORE",
	2: "DISCOVER_OPTION_ONLY_STORE",
}
var DiscoverOption_value = map[string]int32{
	"DISCOVER_OPTION_NONE":       0,
	"DISCOVER_OPTION_NO_STORE":   1,
	"DISCOVER_OPTION_ONLY_STORE": 2,
}

func (x DiscoverOption) String() string {
	return proto.EnumName(DiscoverOption_name, int32(x))
}
func (DiscoverOption) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// AppState defines the possible states of the app.
type AppState int32

const (
	AppState_APP_STATE_UNDEFINED AppState = 0
	AppState_APP_STATE_RUNNING   AppState = 1
	AppState_APP_STATE_EXITED    AppState = 2
)

var AppState_name = map[int32]string{
	0: "APP_STATE_UNDEFINED",
	1: "APP_STATE_RUNNING",
	2: "APP_STATE_EXITED",
}
var AppState_value = map[string]int32{
	"APP_STATE_UNDEFINED": 0,
	"APP_STATE_RUNNING":   1,
	"APP_STATE_EXITED":    2,
}

func (x AppState) String() string {
	return proto.EnumName(AppState_name, int32(x))
}
func (AppState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// PodState defines the possible states of the pod.
// See https://github.com/coreos/rkt/blob/master/Documentation/devel/pod-lifecycle.md for a detailed
// explanation of each state.
type PodState int32

const (
	PodState_POD_STATE_UNDEFINED PodState = 0
	// States before the pod is running.
	PodState_POD_STATE_EMBRYO    PodState = 1
	PodState_POD_STATE_PREPARING PodState = 2
	PodState_POD_STATE_PREPARED  PodState = 3
	// State that indicates the pod is running.
	PodState_POD_STATE_RUNNING PodState = 4
	// States that indicates the pod is exited, and will never run.
	PodState_POD_STATE_ABORTED_PREPARE PodState = 5
	PodState_POD_STATE_EXITED          PodState = 6
	PodState_POD_STATE_DELETING        PodState = 7
	PodState_POD_STATE_GARBAGE         PodState = 8
)

var PodState_name = map[int32]string{
	0: "POD_STATE_UNDEFINED",
	1: "POD_STATE_EMBRYO",
	2: "POD_STATE_PREPARING",
	3: "POD_STATE_PREPARED",
	4: "POD_STATE_RUNNING",
	5: "POD_STATE_ABORTED_PREPARE",
	6: "POD_STATE_EXITED",
	7: "POD_STATE_DELETING",
	8: "POD_STATE_GARBAGE",
}
var PodState_value = map[string]int32{
	"POD_STATE_UNDEFINED":       0,
	"POD_STATE_EMBRYO":          1,
	"POD_STATE_PREPARING":       2,
	"POD_STATE_PREPARED":        3,
	"POD_STATE_RUNNING":         4,
	"POD_STATE_ABORTED_PREPARE": 5,
	"POD_STATE_EXITED":          6,
	"POD_STATE_DELETING":        7,
	"POD_STATE_GARBAGE":         8,
}

func (x PodState) String() string {
	return proto.EnumName(PodState_name, int32(x))
}
func (PodState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// EventType defines the type of the events that will be received via ListenEvents().
type EventType int32

const (
	EventType_EVENT_TYPE_UNDEFINED EventType = 0
	// Pod events.
	EventType_EVENT_TYPE_POD_PREPARED          EventType = 1
	EventType_EVENT_TYPE_POD_PREPARE_ABORTED   EventType = 2
	EventType_EVENT_TYPE_POD_STARTED           EventType = 3
	EventType_EVENT_TYPE_POD_EXITED            EventType = 4
	EventType_EVENT_TYPE_POD_GARBAGE_COLLECTED EventType = 5
	// App events.
	EventType_EVENT_TYPE_APP_STARTED EventType = 6
	EventType_EVENT_TYPE_APP_EXITED  EventType = 7
	// Image events.
	EventType_EVENT_TYPE_IMAGE_IMPORTED EventType = 8
	EventType_EVENT_TYPE_IMAGE_REMOVED  EventType = 9
)

var EventType_name = map[int32]string{
	0: "EVENT_TYPE_UNDEFINED",
	1: "EVENT_TYPE_POD_PREPARED",
	2: "EVENT_TYPE_POD_PREPARE_ABORTED",
	3: "EVENT_TYPE_POD_STARTED",
	4: "EVENT_TYPE_POD_EXITED",
	5: "EVENT_TYPE_POD_GARBAGE_COLLECTED",
	6: "EVENT_TYPE_APP_STARTED",
	7: "EVENT_TYPE_APP_EXITED",
	8: "EVENT_TYPE_IMAGE_IMPORTED",
	9: "EVENT_TYPE_IMAGE_REMOVED",
}
var EventType_value = map[string]int32{
	"EVENT_TYPE_UNDEFINED":             0,
	"EVENT_TYPE_POD_PREPARED":          1,
	"EVENT_TYPE_POD_PREPARE_ABORTED":   2,
	"EVENT_TYPE_POD_STARTED":           3,
	"EVENT_TYPE_POD_EXITED":            4,
	"EVENT_TYPE_POD_GARBAGE_COLLECTED": 5,
	"EVENT_TYPE_APP_STARTED":           6,
	"EVENT_TYPE_APP_EXITED":            7,
	"EVENT_TYPE_IMAGE_IMPORTED":        8,
	"EVENT_TYPE_IMAGE_REMOVED":         9,
}

func (x EventType) String() string {
	return proto.EnumName(EventType_name, int32(x))
}
func (EventType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// FetchImageRequest defines the request for FetchImage.
type FetchImageRequest struct {
	// Type of the image, e.g. aci, docker, oci, etc.
	Type *Image `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	// Resolvable name of the image, used for discovery, can be string, hash, URL, file path.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Insecure options for fetch, it's a bitflag.
	InsecureOption InsecureOption `protobuf:"varint,3,opt,name=insecure_option,enum=v1alpha.InsecureOption" json:"insecure_option,omitempty"`
	// Whether to fetch from the store, or skip the store.
	DiscoverOption DiscoverOption `protobuf:"varint,4,opt,name=discover_option,enum=v1alpha.DiscoverOption" json:"discover_option,omitempty"`
	// Whether to fetch the depedencies.
	WithDeps bool `protobuf:"varint,5,opt,name=with_deps" json:"with_deps,omitempty"`
	// Serialized credential config file, used for fetching.
	// The format is documented at:
	// https://github.com/coreos/rkt/blob/master/Documentation/configuration.md#rktkind-auth
	CredentialsConfg []byte `protobuf:"bytes,6,opt,name=credentials_confg,proto3" json:"credentials_confg,omitempty"`
}

func (m *FetchImageRequest) Reset()                    { *m = FetchImageRequest{} }
func (m *FetchImageRequest) String() string            { return proto.CompactTextString(m) }
func (*FetchImageRequest) ProtoMessage()               {}
func (*FetchImageRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *FetchImageRequest) GetType() *Image {
	if m != nil {
		return m.Type
	}
	return nil
}

// FetchImageResponse defines the response for FetchImage.
type FetchImageResponse struct {
	// ID of the fetched image, which can be used to uniquely identify the image.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *FetchImageResponse) Reset()                    { *m = FetchImageResponse{} }
func (m *FetchImageResponse) String() string            { return proto.CompactTextString(m) }
func (*FetchImageResponse) ProtoMessage()               {}
func (*FetchImageResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// PreparePodRequest defines the request for PreparePod.
type PreparePodRequest struct {
	// The pod manifest to use for preparing.
	PodManifest []byte `protobuf:"bytes,1,opt,name=pod_manifest,proto3" json:"pod_manifest,omitempty"`
}

func (m *PreparePodRequest) Reset()                    { *m = PreparePodRequest{} }
func (m *PreparePodRequest) String() string            { return proto.CompactTextString(m) }
func (*PreparePodRequest) ProtoMessage()               {}
func (*PreparePodRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// PreparePodResponse defines the response for PreparePod.
type PreparePodResponse struct {
	// ID of the prepared rkt pod, which can be used to invoke `rkt run-prepared`.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *PreparePodResponse) Reset()                    { *m = PreparePodResponse{} }
func (m *PreparePodResponse) String() string            { return proto.CompactTextString(m) }
func (*PreparePodResponse) ProtoMessage()               {}
func (*PreparePodResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// RemovePodRequest defines the request for RemovePod.
type RemovePodRequest struct {
	// ID of the pod to remove, when specified, at most one image will be removed.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *RemovePodRequest) Reset()                    { *m = RemovePodRequest{} }
func (m *RemovePodRequest) String() string            { return proto.CompactTextString(m) }
func (*RemovePodRequest) ProtoMessage()               {}
func (*RemovePodRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// RemovePodResponse defines the response for RemovePod.
type RemovePodResponse struct {
}

func (m *RemovePodResponse) Reset()                    { *m = RemovePodResponse{} }
func (m *RemovePodResponse) String() string            { return proto.CompactTextString(m) }
func (*RemovePodResponse) ProtoMessage()               {}
func (*RemovePodResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// RemoveImageRequest defines the request for RemoveImage.
type RemoveImageRequest struct {
	// ID of the image to remove, when specified, at most one image will be removed.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Name of the image to remove, if multiple images have the same name,
	// all of them will be removed.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
}

func (m *RemoveImageRequest) Reset()                    { *m = RemoveImageRequest{} }
func (m *RemoveImageRequest) String() string            { return proto.CompactTextString(m) }
func (*RemoveImageRequest) ProtoMessage()               {}
func (*RemoveImageRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

// RemoveImageResponse defines the response for RemoveImage.
type RemoveImageResponse struct {
}

func (m *RemoveImageResponse) Reset()                    { *m = RemoveImageResponse{} }
func (m *RemoveImageResponse) String() string            { return proto.CompactTextString(m) }
func (*RemoveImageResponse) ProtoMessage()               {}
func (*RemoveImageResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

// EnterPodRequest defines the request for EnterPod.
type EnterPodRequest struct {
	// ID of the pod to enter.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Name of the app inside the pod to enter.
	// This must be non-empty if there are multiple apps in the pod.
	AppName string `protobuf:"bytes,2,opt,name=app_name" json:"app_name,omitempty"`
	// The command to run for enter, optional.
	Command []string `protobuf:"bytes,3,rep,name=command" json:"command,omitempty"`
	// The stdin to for the enter, optional.
	Stdin string `protobuf:"bytes,4,opt,name=stdin" json:"stdin,omitempty"`
}

func (m *EnterPodRequest) Reset()                    { *m = EnterPodRequest{} }
func (m *EnterPodRequest) String() string            { return proto.CompactTextString(m) }
func (*EnterPodRequest) ProtoMessage()               {}
func (*EnterPodRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

// EnterPodResponse defines the response for EnterPod.
type EnterPodResponse struct {
	// The stdout to for the enter, optional.
	Stdout string `protobuf:"bytes,1,opt,name=stdout" json:"stdout,omitempty"`
	// The stderr to for the enter, optional.
	Stderr string `protobuf:"bytes,2,opt,name=stderr" json:"stderr,omitempty"`
}

func (m *EnterPodResponse) Reset()                    { *m = EnterPodResponse{} }
func (m *EnterPodResponse) String() string            { return proto.CompactTextString(m) }
func (*EnterPodResponse) ProtoMessage()               {}
func (*EnterPodResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

// ImageFormat defines the format of the image.
type ImageFormat struct {
	// Type of the image, required.
	Type ImageType `protobuf:"varint,1,opt,name=type,enum=v1alpha.ImageType" json:"type,omitempty"`
	// Version of the image format, required.
	Version string `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
}

func (m *ImageFormat) Reset()                    { *m = ImageFormat{} }
func (m *ImageFormat) String() string            { return proto.CompactTextString(m) }
func (*ImageFormat) ProtoMessage()               {}
func (*ImageFormat) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

// Image describes the image's information.
type Image struct {
	// Base format of the image, required. This indicates the original format
	// for the image as nowadays all the image formats will be transformed to
	// ACI.
	BaseFormat *ImageFormat `protobuf:"bytes,1,opt,name=base_format" json:"base_format,omitempty"`
	// ID of the image, a string that can be used to uniquely identify the image,
	// e.g. sha512 hash of the ACIs, required.
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// Name of the image in the image manifest, e.g. 'coreos.com/etcd', optional.
	Name string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// Version of the image, e.g. 'latest', '2.0.10', optional.
	Version string `protobuf:"bytes,4,opt,name=version" json:"version,omitempty"`
	// Timestamp of when the image is imported, it is the seconds since epoch, optional.
	ImportTimestamp int64 `protobuf:"varint,5,opt,name=import_timestamp" json:"import_timestamp,omitempty"`
	// JSON-encoded byte array that represents the image manifest, optional.
	Manifest []byte `protobuf:"bytes,6,opt,name=manifest,proto3" json:"manifest,omitempty"`
	// Size is the size in bytes of this image in the store.
	Size int64 `protobuf:"varint,7,opt,name=size" json:"size,omitempty"`
	// Annotations on this image.
	Annotations []*KeyValue `protobuf:"bytes,8,rep,name=annotations" json:"annotations,omitempty"`
	// Labels of this image.
	Labels []*KeyValue `protobuf:"bytes,9,rep,name=labels" json:"labels,omitempty"`
}

func (m *Image) Reset()                    { *m = Image{} }
func (m *Image) String() string            { return proto.CompactTextString(m) }
func (*Image) ProtoMessage()               {}
func (*Image) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Image) GetBaseFormat() *ImageFormat {
	if m != nil {
		return m.BaseFormat
	}
	return nil
}

func (m *Image) GetAnnotations() []*KeyValue {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Image) GetLabels() []*KeyValue {
	if m != nil {
		return m.Labels
	}
	return nil
}

// Network describes the network information of a pod.
type Network struct {
	// Name of the network that a pod belongs to, required.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Pod's IPv4 address within the network, optional if IPv6 address is given.
	Ipv4 string `protobuf:"bytes,2,opt,name=ipv4" json:"ipv4,omitempty"`
	// Pod's IPv6 address within the network, optional if IPv4 address is given.
	Ipv6 string `protobuf:"bytes,3,opt,name=ipv6" json:"ipv6,omitempty"`
}

func (m *Network) Reset()                    { *m = Network{} }
func (m *Network) String() string            { return proto.CompactTextString(m) }
func (*Network) ProtoMessage()               {}
func (*Network) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

// App describes the information of an app that's running in a pod.
type App struct {
	// Name of the app, required.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Image used by the app, required. However, this may only contain the image id
	// if it is returned by ListPods().
	Image *Image `protobuf:"bytes,2,opt,name=image" json:"image,omitempty"`
	// State of the app. optional, non-empty only if it's returned by InspectPod().
	State AppState `protobuf:"varint,3,opt,name=state,enum=v1alpha.AppState" json:"state,omitempty"`
	// Exit code of the app. optional, only valid if it's returned by InspectPod() and
	// the app has already exited.
	ExitCode int32 `protobuf:"zigzag32,4,opt,name=exit_code" json:"exit_code,omitempty"`
	// Annotations for this app.
	Annotations []*KeyValue `protobuf:"bytes,5,rep,name=annotations" json:"annotations,omitempty"`
}

func (m *App) Reset()                    { *m = App{} }
func (m *App) String() string            { return proto.CompactTextString(m) }
func (*App) ProtoMessage()               {}
func (*App) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *App) GetImage() *Image {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *App) GetAnnotations() []*KeyValue {
	if m != nil {
		return m.Annotations
	}
	return nil
}

// Pod describes a pod's information.
// If a pod is in Embryo, Preparing, AbortedPrepare state,
// only id and state will be returned.
//
// If a pod is in other states, the pod manifest and
// apps will be returned when 'detailed' is true in the request.
//
// A valid pid of the stage1 process of the pod will be returned
// if the pod is Running has run once.
//
// Networks are only returned when a pod is in Running.
type Pod struct {
	// ID of the pod, in the form of a UUID.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// PID of the stage1 process of the pod.
	Pid int32 `protobuf:"zigzag32,2,opt,name=pid" json:"pid,omitempty"`
	// State of the pod.
	State PodState `protobuf:"varint,3,opt,name=state,enum=v1alpha.PodState" json:"state,omitempty"`
	// List of apps in the pod.
	Apps []*App `protobuf:"bytes,4,rep,name=apps" json:"apps,omitempty"`
	// Network information of the pod.
	// Note that a pod can be in multiple networks.
	Networks []*Network `protobuf:"bytes,5,rep,name=networks" json:"networks,omitempty"`
	// JSON-encoded byte array that represents the pod manifest of the pod.
	Manifest []byte `protobuf:"bytes,6,opt,name=manifest,proto3" json:"manifest,omitempty"`
	// Annotations on this pod.
	Annotations []*KeyValue `protobuf:"bytes,7,rep,name=annotations" json:"annotations,omitempty"`
	// Cgroup of the pod, empty if the pod is not running.
	Cgroup string `protobuf:"bytes,8,opt,name=cgroup" json:"cgroup,omitempty"`
	// Timestamp of when the pod is created, nanoseconds since epoch.
	// Zero if the pod is not created.
	CreatedAt int64 `protobuf:"varint,9,opt,name=created_at" json:"created_at,omitempty"`
	// Timestamp of when the pod is started, nanoseconds since epoch.
	// Zero if the pod is not started.
	StartedAt int64 `protobuf:"varint,10,opt,name=started_at" json:"started_at,omitempty"`
	// Timestamp of when the pod is moved to exited-garbage/garbage,
	// in nanoseconds since epoch.
	// Zero if the pod is not moved to exited-garbage/garbage yet.
	GcMarkedAt int64 `protobuf:"varint,11,opt,name=gc_marked_at" json:"gc_marked_at,omitempty"`
}

func (m *Pod) Reset()                    { *m = Pod{} }
func (m *Pod) String() string            { return proto.CompactTextString(m) }
func (*Pod) ProtoMessage()               {}
func (*Pod) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *Pod) GetApps() []*App {
	if m != nil {
		return m.Apps
	}
	return nil
}

func (m *Pod) GetNetworks() []*Network {
	if m != nil {
		return m.Networks
	}
	return nil
}

func (m *Pod) GetAnnotations() []*KeyValue {
	if m != nil {
		return m.Annotations
	}
	return nil
}

type KeyValue struct {
	// Key part of the key-value pair.
	Key string `protobuf:"bytes,1,opt,name=Key" json:"Key,omitempty"`
	// Value part of the key-value pair.
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *KeyValue) Reset()                    { *m = KeyValue{} }
func (m *KeyValue) String() string            { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()               {}
func (*KeyValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

// PodFilter defines the condition that the returned pods need to satisfy in ListPods().
// The conditions are combined by 'AND', and different filters are combined by 'OR'.
type PodFilter struct {
	// If not empty, the pods that have any of the ids will be returned.
	Ids []string `protobuf:"bytes,1,rep,name=ids" json:"ids,omitempty"`
	// If not empty, the pods that have any of the states will be returned.
	States []PodState `protobuf:"varint,2,rep,name=states,enum=v1alpha.PodState" json:"states,omitempty"`
	// If not empty, the pods that all of the apps will be returned.
	AppNames []string `protobuf:"bytes,3,rep,name=app_names" json:"app_names,omitempty"`
	// If not empty, the pods that have all of the images(in the apps) will be returned
	ImageIds []string `protobuf:"bytes,4,rep,name=image_ids" json:"image_ids,omitempty"`
	// If not empty, the pods that are in all of the networks will be returned.
	NetworkNames []string `protobuf:"bytes,5,rep,name=network_names" json:"network_names,omitempty"`
	// If not empty, the pods that have all of the annotations will be returned.
	Annotations []*KeyValue `protobuf:"bytes,6,rep,name=annotations" json:"annotations,omitempty"`
	// If not empty, the pods whose cgroup are listed will be returned.
	Cgroups []string `protobuf:"bytes,7,rep,name=cgroups" json:"cgroups,omitempty"`
	// If not empty, the pods whose these cgroup belong to will be returned.
	// i.e. the pod's cgroup is a prefix of the specified cgroup
	PodSubCgroups []string `protobuf:"bytes,8,rep,name=pod_sub_cgroups" json:"pod_sub_cgroups,omitempty"`
}

func (m *PodFilter) Reset()                    { *m = PodFilter{} }
func (m *PodFilter) String() string            { return proto.CompactTextString(m) }
func (*PodFilter) ProtoMessage()               {}
func (*PodFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *PodFilter) GetAnnotations() []*KeyValue {
	if m != nil {
		return m.Annotations
	}
	return nil
}

// ImageFilter defines the condition that the returned images need to satisfy in ListImages().
// The conditions are combined by 'AND', and different filters are combined by 'OR'.
type ImageFilter struct {
	// If not empty, the images that have any of the ids will be returned.
	Ids []string `protobuf:"bytes,1,rep,name=ids" json:"ids,omitempty"`
	// if not empty, the images that have any of the prefixes in the name will be returned.
	Prefixes []string `protobuf:"bytes,2,rep,name=prefixes" json:"prefixes,omitempty"`
	// If not empty, the images that have any of the base names will be returned.
	// For example, both 'coreos.com/etcd' and 'k8s.io/etcd' will be returned if 'etcd' is included,
	// however 'k8s.io/etcd-backup' will not be returned.
	BaseNames []string `protobuf:"bytes,3,rep,name=base_names" json:"base_names,omitempty"`
	// If not empty, the images that have any of the keywords in the name will be returned.
	// For example, both 'kubernetes-etcd', 'etcd:latest' will be returned if 'etcd' is included,
	Keywords []string `protobuf:"bytes,4,rep,name=keywords" json:"keywords,omitempty"`
	// If not empty, the images that have all of the labels will be returned.
	Labels []*KeyValue `protobuf:"bytes,5,rep,name=labels" json:"labels,omitempty"`
	// If set, the images that are imported after this timestamp will be returned.
	ImportedAfter int64 `protobuf:"varint,6,opt,name=imported_after" json:"imported_after,omitempty"`
	// If set, the images that are imported before this timestamp will be returned.
	ImportedBefore int64 `protobuf:"varint,7,opt,name=imported_before" json:"imported_before,omitempty"`
	// If not empty, the images that have all of the annotations will be returned.
	Annotations []*KeyValue `protobuf:"bytes,8,rep,name=annotations" json:"annotations,omitempty"`
	// If not empty, the images that have any of the exact full names will be returned.
	FullNames []string `protobuf:"bytes,9,rep,name=full_names" json:"full_names,omitempty"`
}

func (m *ImageFilter) Reset()                    { *m = ImageFilter{} }
func (m *ImageFilter) String() string            { return proto.CompactTextString(m) }
func (*ImageFilter) ProtoMessage()               {}
func (*ImageFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *ImageFilter) GetLabels() []*KeyValue {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ImageFilter) GetAnnotations() []*KeyValue {
	if m != nil {
		return m.Annotations
	}
	return nil
}

// GlobalFlags describes the flags that passed to rkt api service when it is launched.
type GlobalFlags struct {
	// Data directory.
	Dir string `protobuf:"bytes,1,opt,name=dir" json:"dir,omitempty"`
	// System configuration directory.
	SystemConfigDir string `protobuf:"bytes,2,opt,name=system_config_dir" json:"system_config_dir,omitempty"`
	// Local configuration directory.
	LocalConfigDir string `protobuf:"bytes,3,opt,name=local_config_dir" json:"local_config_dir,omitempty"`
	// User configuration directory.
	UserConfigDir string `protobuf:"bytes,4,opt,name=user_config_dir" json:"user_config_dir,omitempty"`
	// Insecure flags configurates what security features to disable.
	InsecureFlags string `protobuf:"bytes,5,opt,name=insecure_flags" json:"insecure_flags,omitempty"`
	// Whether to automatically trust gpg keys fetched from https
	TrustKeysFromHttps bool `protobuf:"varint,6,opt,name=trust_keys_from_https" json:"trust_keys_from_https,omitempty"`
}

func (m *GlobalFlags) Reset()                    { *m = GlobalFlags{} }
func (m *GlobalFlags) String() string            { return proto.CompactTextString(m) }
func (*GlobalFlags) ProtoMessage()               {}
func (*GlobalFlags) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

// Info describes the information of rkt on the machine.
type Info struct {
	// Version of rkt, required, in the form of Semantic Versioning 2.0.0 (http://semver.org/).
	RktVersion string `protobuf:"bytes,1,opt,name=rkt_version" json:"rkt_version,omitempty"`
	// Version of appc, required, in the form of Semantic Versioning 2.0.0 (http://semver.org/).
	AppcVersion string `protobuf:"bytes,2,opt,name=appc_version" json:"appc_version,omitempty"`
	// Latest version of the api that's supported by the service, required, in the form of Semantic Versioning 2.0.0 (http://semver.org/).
	ApiVersion string `protobuf:"bytes,3,opt,name=api_version" json:"api_version,omitempty"`
	// The global flags that passed to the rkt api service when it's launched.
	GlobalFlags *GlobalFlags `protobuf:"bytes,4,opt,name=global_flags" json:"global_flags,omitempty"`
}

func (m *Info) Reset()                    { *m = Info{} }
func (m *Info) String() string            { return proto.CompactTextString(m) }
func (*Info) ProtoMessage()               {}
func (*Info) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *Info) GetGlobalFlags() *GlobalFlags {
	if m != nil {
		return m.GlobalFlags
	}
	return nil
}

// Event describes the events that will be received via ListenEvents().
type Event struct {
	// Type of the event, required.
	Type EventType `protobuf:"varint,1,opt,name=type,enum=v1alpha.EventType" json:"type,omitempty"`
	// ID of the subject that causes the event, required.
	// If the event is a pod or app event, the id is the pod's uuid.
	// If the event is an image event, the id is the image's id.
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// Name of the subject that causes the event, required.
	// If the event is a pod event, the name is the pod's name.
	// If the event is an app event, the name is the app's name.
	// If the event is an image event, the name is the image's name.
	From string `protobuf:"bytes,3,opt,name=from" json:"from,omitempty"`
	// Timestamp of when the event happens, it is the seconds since epoch, required.
	Time int64 `protobuf:"varint,4,opt,name=time" json:"time,omitempty"`
	// Data of the event, in the form of key-value pairs, optional.
	Data []*KeyValue `protobuf:"bytes,5,rep,name=data" json:"data,omitempty"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *Event) GetData() []*KeyValue {
	if m != nil {
		return m.Data
	}
	return nil
}

// EventFilter defines the condition that the returned events needs to satisfy in ListImages().
// The condition are combined by 'AND'.
type EventFilter struct {
	// If not empty, then only returns the events that have the listed types.
	Types []EventType `protobuf:"varint,1,rep,name=types,enum=v1alpha.EventType" json:"types,omitempty"`
	// If not empty, then only returns the events whose 'id' is included in the listed ids.
	Ids []string `protobuf:"bytes,2,rep,name=ids" json:"ids,omitempty"`
	// If not empty, then only returns the events whose 'from' is included in the listed names.
	Names []string `protobuf:"bytes,3,rep,name=names" json:"names,omitempty"`
	// If set, then only returns the events after this timestamp.
	// If the server starts after since_time, then only the events happened after the start of the server will be returned.
	// If since_time is a future timestamp, then no events will be returned until that time.
	SinceTime int64 `protobuf:"varint,4,opt,name=since_time" json:"since_time,omitempty"`
	// If set, then only returns the events before this timestamp.
	// If it is a future timestamp, then the event stream will be closed at that moment.
	UntilTime int64 `protobuf:"varint,5,opt,name=until_time" json:"until_time,omitempty"`
}

func (m *EventFilter) Reset()                    { *m = EventFilter{} }
func (m *EventFilter) String() string            { return proto.CompactTextString(m) }
func (*EventFilter) ProtoMessage()               {}
func (*EventFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

// Request for GetInfo().
type GetInfoRequest struct {
}

func (m *GetInfoRequest) Reset()                    { *m = GetInfoRequest{} }
func (m *GetInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*GetInfoRequest) ProtoMessage()               {}
func (*GetInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

// Response for GetInfo().
type GetInfoResponse struct {
	Info *Info `protobuf:"bytes,1,opt,name=info" json:"info,omitempty"`
}

func (m *GetInfoResponse) Reset()                    { *m = GetInfoResponse{} }
func (m *GetInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*GetInfoResponse) ProtoMessage()               {}
func (*GetInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *GetInfoResponse) GetInfo() *Info {
	if m != nil {
		return m.Info
	}
	return nil
}

// Request for ListPods().
type ListPodsRequest struct {
	Filters []*PodFilter `protobuf:"bytes,1,rep,name=filters" json:"filters,omitempty"`
	Detail  bool         `protobuf:"varint,2,opt,name=detail" json:"detail,omitempty"`
}

func (m *ListPodsRequest) Reset()                    { *m = ListPodsRequest{} }
func (m *ListPodsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListPodsRequest) ProtoMessage()               {}
func (*ListPodsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *ListPodsRequest) GetFilters() []*PodFilter {
	if m != nil {
		return m.Filters
	}
	return nil
}

// Response for ListPods().
type ListPodsResponse struct {
	Pods []*Pod `protobuf:"bytes,1,rep,name=pods" json:"pods,omitempty"`
}

func (m *ListPodsResponse) Reset()                    { *m = ListPodsResponse{} }
func (m *ListPodsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListPodsResponse) ProtoMessage()               {}
func (*ListPodsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *ListPodsResponse) GetPods() []*Pod {
	if m != nil {
		return m.Pods
	}
	return nil
}

// Request for InspectPod().
type InspectPodRequest struct {
	// ID of the pod which we are querying status for, required.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *InspectPodRequest) Reset()                    { *m = InspectPodRequest{} }
func (m *InspectPodRequest) String() string            { return proto.CompactTextString(m) }
func (*InspectPodRequest) ProtoMessage()               {}
func (*InspectPodRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

// Response for InspectPod().
type InspectPodResponse struct {
	Pod *Pod `protobuf:"bytes,1,opt,name=pod" json:"pod,omitempty"`
}

func (m *InspectPodResponse) Reset()                    { *m = InspectPodResponse{} }
func (m *InspectPodResponse) String() string            { return proto.CompactTextString(m) }
func (*InspectPodResponse) ProtoMessage()               {}
func (*InspectPodResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *InspectPodResponse) GetPod() *Pod {
	if m != nil {
		return m.Pod
	}
	return nil
}

// Request for ListImages().
type ListImagesRequest struct {
	Filters []*ImageFilter `protobuf:"bytes,1,rep,name=filters" json:"filters,omitempty"`
	Detail  bool           `protobuf:"varint,2,opt,name=detail" json:"detail,omitempty"`
}

func (m *ListImagesRequest) Reset()                    { *m = ListImagesRequest{} }
func (m *ListImagesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListImagesRequest) ProtoMessage()               {}
func (*ListImagesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *ListImagesRequest) GetFilters() []*ImageFilter {
	if m != nil {
		return m.Filters
	}
	return nil
}

// Response for ListImages().
type ListImagesResponse struct {
	Images []*Image `protobuf:"bytes,1,rep,name=images" json:"images,omitempty"`
}

func (m *ListImagesResponse) Reset()                    { *m = ListImagesResponse{} }
func (m *ListImagesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListImagesResponse) ProtoMessage()               {}
func (*ListImagesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *ListImagesResponse) GetImages() []*Image {
	if m != nil {
		return m.Images
	}
	return nil
}

// Request for InspectImage().
type InspectImageRequest struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *InspectImageRequest) Reset()                    { *m = InspectImageRequest{} }
func (m *InspectImageRequest) String() string            { return proto.CompactTextString(m) }
func (*InspectImageRequest) ProtoMessage()               {}
func (*InspectImageRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

// Response for InspectImage().
type InspectImageResponse struct {
	Image *Image `protobuf:"bytes,1,opt,name=image" json:"image,omitempty"`
}

func (m *InspectImageResponse) Reset()                    { *m = InspectImageResponse{} }
func (m *InspectImageResponse) String() string            { return proto.CompactTextString(m) }
func (*InspectImageResponse) ProtoMessage()               {}
func (*InspectImageResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *InspectImageResponse) GetImage() *Image {
	if m != nil {
		return m.Image
	}
	return nil
}

// Request for ListenEvents().
type ListenEventsRequest struct {
	Filter *EventFilter `protobuf:"bytes,1,opt,name=filter" json:"filter,omitempty"`
}

func (m *ListenEventsRequest) Reset()                    { *m = ListenEventsRequest{} }
func (m *ListenEventsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListenEventsRequest) ProtoMessage()               {}
func (*ListenEventsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *ListenEventsRequest) GetFilter() *EventFilter {
	if m != nil {
		return m.Filter
	}
	return nil
}

// Response for ListenEvents().
type ListenEventsResponse struct {
	// Aggregate multiple events to reduce round trips, optional as the response can contain no events.
	Events []*Event `protobuf:"bytes,1,rep,name=events" json:"events,omitempty"`
}

func (m *ListenEventsResponse) Reset()                    { *m = ListenEventsResponse{} }
func (m *ListenEventsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListenEventsResponse) ProtoMessage()               {}
func (*ListenEventsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *ListenEventsResponse) GetEvents() []*Event {
	if m != nil {
		return m.Events
	}
	return nil
}

// Request for GetLogs().
type GetLogsRequest struct {
	// ID of the pod which we will get logs from, required.
	PodId string `protobuf:"bytes,1,opt,name=pod_id" json:"pod_id,omitempty"`
	// Name of the app within the pod which we will get logs
	// from, optional. If not set, then the logs of all the
	// apps within the pod will be returned.
	AppName string `protobuf:"bytes,2,opt,name=app_name" json:"app_name,omitempty"`
	// Number of most recent lines to return, optional.
	Lines int32 `protobuf:"varint,3,opt,name=lines" json:"lines,omitempty"`
	// If true, then a response stream will not be closed,
	// and new log response will be sent via the stream, default is false.
	Follow bool `protobuf:"varint,4,opt,name=follow" json:"follow,omitempty"`
	// If set, then only the logs after the timestamp will
	// be returned, optional.
	SinceTime int64 `protobuf:"varint,5,opt,name=since_time" json:"since_time,omitempty"`
	// If set, then only the logs before the timestamp will
	// be returned, optional.
	UntilTime int64 `protobuf:"varint,6,opt,name=until_time" json:"until_time,omitempty"`
}

func (m *GetLogsRequest) Reset()                    { *m = GetLogsRequest{} }
func (m *GetLogsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLogsRequest) ProtoMessage()               {}
func (*GetLogsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

// Response for GetLogs().
type GetLogsResponse struct {
	// List of the log lines that returned, optional as the response can contain no logs.
	Lines []string `protobuf:"bytes,1,rep,name=lines" json:"lines,omitempty"`
}

func (m *GetLogsResponse) Reset()                    { *m = GetLogsResponse{} }
func (m *GetLogsResponse) String() string            { return proto.CompactTextString(m) }
func (*GetLogsResponse) ProtoMessage()               {}
func (*GetLogsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func init() {
	proto.RegisterType((*FetchImageRequest)(nil), "v1alpha.FetchImageRequest")
	proto.RegisterType((*FetchImageResponse)(nil), "v1alpha.FetchImageResponse")
	proto.RegisterType((*PreparePodRequest)(nil), "v1alpha.PreparePodRequest")
	proto.RegisterType((*PreparePodResponse)(nil), "v1alpha.PreparePodResponse")
	proto.RegisterType((*RemovePodRequest)(nil), "v1alpha.RemovePodRequest")
	proto.RegisterType((*RemovePodResponse)(nil), "v1alpha.RemovePodResponse")
	proto.RegisterType((*RemoveImageRequest)(nil), "v1alpha.RemoveImageRequest")
	proto.RegisterType((*RemoveImageResponse)(nil), "v1alpha.RemoveImageResponse")
	proto.RegisterType((*EnterPodRequest)(nil), "v1alpha.EnterPodRequest")
	proto.RegisterType((*EnterPodResponse)(nil), "v1alpha.EnterPodResponse")
	proto.RegisterType((*ImageFormat)(nil), "v1alpha.ImageFormat")
	proto.RegisterType((*Image)(nil), "v1alpha.Image")
	proto.RegisterType((*Network)(nil), "v1alpha.Network")
	proto.RegisterType((*App)(nil), "v1alpha.App")
	proto.RegisterType((*Pod)(nil), "v1alpha.Pod")
	proto.RegisterType((*KeyValue)(nil), "v1alpha.KeyValue")
	proto.RegisterType((*PodFilter)(nil), "v1alpha.PodFilter")
	proto.RegisterType((*ImageFilter)(nil), "v1alpha.ImageFilter")
	proto.RegisterType((*GlobalFlags)(nil), "v1alpha.GlobalFlags")
	proto.RegisterType((*Info)(nil), "v1alpha.Info")
	proto.RegisterType((*Event)(nil), "v1alpha.Event")
	proto.RegisterType((*EventFilter)(nil), "v1alpha.EventFilter")
	proto.RegisterType((*GetInfoRequest)(nil), "v1alpha.GetInfoRequest")
	proto.RegisterType((*GetInfoResponse)(nil), "v1alpha.GetInfoResponse")
	proto.RegisterType((*ListPodsRequest)(nil), "v1alpha.ListPodsRequest")
	proto.RegisterType((*ListPodsResponse)(nil), "v1alpha.ListPodsResponse")
	proto.RegisterType((*InspectPodRequest)(nil), "v1alpha.InspectPodRequest")
	proto.RegisterType((*InspectPodResponse)(nil), "v1alpha.InspectPodResponse")
	proto.RegisterType((*ListImagesRequest)(nil), "v1alpha.ListImagesRequest")
	proto.RegisterType((*ListImagesResponse)(nil), "v1alpha.ListImagesResponse")
	proto.RegisterType((*InspectImageRequest)(nil), "v1alpha.InspectImageRequest")
	proto.RegisterType((*InspectImageResponse)(nil), "v1alpha.InspectImageResponse")
	proto.RegisterType((*ListenEventsRequest)(nil), "v1alpha.ListenEventsRequest")
	proto.RegisterType((*ListenEventsResponse)(nil), "v1alpha.ListenEventsResponse")
	proto.RegisterType((*GetLogsRequest)(nil), "v1alpha.GetLogsRequest")
	proto.RegisterType((*GetLogsResponse)(nil), "v1alpha.GetLogsResponse")
	proto.RegisterEnum("v1alpha.ImageType", ImageType_name, ImageType_value)
	proto.RegisterEnum("v1alpha.InsecureOption", InsecureOption_name, InsecureOption_value)
	proto.RegisterEnum("v1alpha.DiscoverOption", DiscoverOption_name, DiscoverOption_value)
	proto.RegisterEnum("v1alpha.AppState", AppState_name, AppState_value)
	proto.RegisterEnum("v1alpha.PodState", PodState_name, PodState_value)
	proto.RegisterEnum("v1alpha.EventType", EventType_name, EventType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for PublicAPI service

type PublicAPIClient interface {
	// GetInfo gets the rkt's information on the machine.
	GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error)
	// ListPods lists rkt pods on the machine.
	ListPods(ctx context.Context, in *ListPodsRequest, opts ...grpc.CallOption) (*ListPodsResponse, error)
	// InspectPod gets detailed pod information of the specified pod.
	InspectPod(ctx context.Context, in *InspectPodRequest, opts ...grpc.CallOption) (*InspectPodResponse, error)
	// ListImages lists the images on the machine.
	ListImages(ctx context.Context, in *ListImagesRequest, opts ...grpc.CallOption) (*ListImagesResponse, error)
	// InspectImage gets the detailed image information of the specified image.
	InspectImage(ctx context.Context, in *InspectImageRequest, opts ...grpc.CallOption) (*InspectImageResponse, error)
	// ListenEvents listens for the events, it will return a response stream
	// that will contain event objects.
	ListenEvents(ctx context.Context, in *ListenEventsRequest, opts ...grpc.CallOption) (PublicAPI_ListenEventsClient, error)
	// GetLogs gets the logs for a pod, if the app is also specified, then only the logs
	// of the app will be returned.
	//
	// If 'follow' in the 'GetLogsRequest' is set to 'true', then the response stream
	// will not be closed after the first response, the future logs will be sent via
	// the stream.
	GetLogs(ctx context.Context, in *GetLogsRequest, opts ...grpc.CallOption) (PublicAPI_GetLogsClient, error)
}

type publicAPIClient struct {
	cc *grpc.ClientConn
}

func NewPublicAPIClient(cc *grpc.ClientConn) PublicAPIClient {
	return &publicAPIClient{cc}
}

func (c *publicAPIClient) GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error) {
	out := new(GetInfoResponse)
	err := grpc.Invoke(ctx, "/v1alpha.PublicAPI/GetInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicAPIClient) ListPods(ctx context.Context, in *ListPodsRequest, opts ...grpc.CallOption) (*ListPodsResponse, error) {
	out := new(ListPodsResponse)
	err := grpc.Invoke(ctx, "/v1alpha.PublicAPI/ListPods", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicAPIClient) InspectPod(ctx context.Context, in *InspectPodRequest, opts ...grpc.CallOption) (*InspectPodResponse, error) {
	out := new(InspectPodResponse)
	err := grpc.Invoke(ctx, "/v1alpha.PublicAPI/InspectPod", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicAPIClient) ListImages(ctx context.Context, in *ListImagesRequest, opts ...grpc.CallOption) (*ListImagesResponse, error) {
	out := new(ListImagesResponse)
	err := grpc.Invoke(ctx, "/v1alpha.PublicAPI/ListImages", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicAPIClient) InspectImage(ctx context.Context, in *InspectImageRequest, opts ...grpc.CallOption) (*InspectImageResponse, error) {
	out := new(InspectImageResponse)
	err := grpc.Invoke(ctx, "/v1alpha.PublicAPI/InspectImage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicAPIClient) ListenEvents(ctx context.Context, in *ListenEventsRequest, opts ...grpc.CallOption) (PublicAPI_ListenEventsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_PublicAPI_serviceDesc.Streams[0], c.cc, "/v1alpha.PublicAPI/ListenEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &publicAPIListenEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PublicAPI_ListenEventsClient interface {
	Recv() (*ListenEventsResponse, error)
	grpc.ClientStream
}

type publicAPIListenEventsClient struct {
	grpc.ClientStream
}

func (x *publicAPIListenEventsClient) Recv() (*ListenEventsResponse, error) {
	m := new(ListenEventsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *publicAPIClient) GetLogs(ctx context.Context, in *GetLogsRequest, opts ...grpc.CallOption) (PublicAPI_GetLogsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_PublicAPI_serviceDesc.Streams[1], c.cc, "/v1alpha.PublicAPI/GetLogs", opts...)
	if err != nil {
		return nil, err
	}
	x := &publicAPIGetLogsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PublicAPI_GetLogsClient interface {
	Recv() (*GetLogsResponse, error)
	grpc.ClientStream
}

type publicAPIGetLogsClient struct {
	grpc.ClientStream
}

func (x *publicAPIGetLogsClient) Recv() (*GetLogsResponse, error) {
	m := new(GetLogsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for PublicAPI service

type PublicAPIServer interface {
	// GetInfo gets the rkt's information on the machine.
	GetInfo(context.Context, *GetInfoRequest) (*GetInfoResponse, error)
	// ListPods lists rkt pods on the machine.
	ListPods(context.Context, *ListPodsRequest) (*ListPodsResponse, error)
	// InspectPod gets detailed pod information of the specified pod.
	InspectPod(context.Context, *InspectPodRequest) (*InspectPodResponse, error)
	// ListImages lists the images on the machine.
	ListImages(context.Context, *ListImagesRequest) (*ListImagesResponse, error)
	// InspectImage gets the detailed image information of the specified image.
	InspectImage(context.Context, *InspectImageRequest) (*InspectImageResponse, error)
	// ListenEvents listens for the events, it will return a response stream
	// that will contain event objects.
	ListenEvents(*ListenEventsRequest, PublicAPI_ListenEventsServer) error
	// GetLogs gets the logs for a pod, if the app is also specified, then only the logs
	// of the app will be returned.
	//
	// If 'follow' in the 'GetLogsRequest' is set to 'true', then the response stream
	// will not be closed after the first response, the future logs will be sent via
	// the stream.
	GetLogs(*GetLogsRequest, PublicAPI_GetLogsServer) error
}

func RegisterPublicAPIServer(s *grpc.Server, srv PublicAPIServer) {
	s.RegisterService(&_PublicAPI_serviceDesc, srv)
}

func _PublicAPI_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(PublicAPIServer).GetInfo(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _PublicAPI_ListPods_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ListPodsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(PublicAPIServer).ListPods(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _PublicAPI_InspectPod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(InspectPodRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(PublicAPIServer).InspectPod(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _PublicAPI_ListImages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ListImagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(PublicAPIServer).ListImages(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _PublicAPI_InspectImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(InspectImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(PublicAPIServer).InspectImage(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _PublicAPI_ListenEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListenEventsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PublicAPIServer).ListenEvents(m, &publicAPIListenEventsServer{stream})
}

type PublicAPI_ListenEventsServer interface {
	Send(*ListenEventsResponse) error
	grpc.ServerStream
}

type publicAPIListenEventsServer struct {
	grpc.ServerStream
}

func (x *publicAPIListenEventsServer) Send(m *ListenEventsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _PublicAPI_GetLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PublicAPIServer).GetLogs(m, &publicAPIGetLogsServer{stream})
}

type PublicAPI_GetLogsServer interface {
	Send(*GetLogsResponse) error
	grpc.ServerStream
}

type publicAPIGetLogsServer struct {
	grpc.ServerStream
}

func (x *publicAPIGetLogsServer) Send(m *GetLogsResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _PublicAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "v1alpha.PublicAPI",
	HandlerType: (*PublicAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetInfo",
			Handler:    _PublicAPI_GetInfo_Handler,
		},
		{
			MethodName: "ListPods",
			Handler:    _PublicAPI_ListPods_Handler,
		},
		{
			MethodName: "InspectPod",
			Handler:    _PublicAPI_InspectPod_Handler,
		},
		{
			MethodName: "ListImages",
			Handler:    _PublicAPI_ListImages_Handler,
		},
		{
			MethodName: "InspectImage",
			Handler:    _PublicAPI_InspectImage_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListenEvents",
			Handler:       _PublicAPI_ListenEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetLogs",
			Handler:       _PublicAPI_GetLogs_Handler,
			ServerStreams: true,
		},
	},
}

// Client API for PublicWriteOnlyAPI service

type PublicWriteOnlyAPIClient interface {
	// FetchImage fetches a container image into the image store.
	FetchImage(ctx context.Context, in *FetchImageRequest, opts ...grpc.CallOption) (*FetchImageResponse, error)
	// PreparePod prepares a pod, currently it only supports preparing from a pod manifest.
	PreparePod(ctx context.Context, in *PreparePodRequest, opts ...grpc.CallOption) (*PreparePodResponse, error)
	// RemovePod removes a pod.
	RemovePod(ctx context.Context, in *RemovePodRequest, opts ...grpc.CallOption) (*RemovePodResponse, error)
	// RemoveImage removes a container image from the image store.
	RemoveImage(ctx context.Context, in *RemoveImageRequest, opts ...grpc.CallOption) (*RemoveImageResponse, error)
	// EnterPod enters the pod's namespace, it also returns a stream where the client can
	// read stdout and stderr.
	EnterPod(ctx context.Context, opts ...grpc.CallOption) (PublicWriteOnlyAPI_EnterPodClient, error)
}

type publicWriteOnlyAPIClient struct {
	cc *grpc.ClientConn
}

func NewPublicWriteOnlyAPIClient(cc *grpc.ClientConn) PublicWriteOnlyAPIClient {
	return &publicWriteOnlyAPIClient{cc}
}

func (c *publicWriteOnlyAPIClient) FetchImage(ctx context.Context, in *FetchImageRequest, opts ...grpc.CallOption) (*FetchImageResponse, error) {
	out := new(FetchImageResponse)
	err := grpc.Invoke(ctx, "/v1alpha.PublicWriteOnlyAPI/FetchImage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicWriteOnlyAPIClient) PreparePod(ctx context.Context, in *PreparePodRequest, opts ...grpc.CallOption) (*PreparePodResponse, error) {
	out := new(PreparePodResponse)
	err := grpc.Invoke(ctx, "/v1alpha.PublicWriteOnlyAPI/PreparePod", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicWriteOnlyAPIClient) RemovePod(ctx context.Context, in *RemovePodRequest, opts ...grpc.CallOption) (*RemovePodResponse, error) {
	out := new(RemovePodResponse)
	err := grpc.Invoke(ctx, "/v1alpha.PublicWriteOnlyAPI/RemovePod", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicWriteOnlyAPIClient) RemoveImage(ctx context.Context, in *RemoveImageRequest, opts ...grpc.CallOption) (*RemoveImageResponse, error) {
	out := new(RemoveImageResponse)
	err := grpc.Invoke(ctx, "/v1alpha.PublicWriteOnlyAPI/RemoveImage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicWriteOnlyAPIClient) EnterPod(ctx context.Context, opts ...grpc.CallOption) (PublicWriteOnlyAPI_EnterPodClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_PublicWriteOnlyAPI_serviceDesc.Streams[0], c.cc, "/v1alpha.PublicWriteOnlyAPI/EnterPod", opts...)
	if err != nil {
		return nil, err
	}
	x := &publicWriteOnlyAPIEnterPodClient{stream}
	return x, nil
}

type PublicWriteOnlyAPI_EnterPodClient interface {
	Send(*EnterPodRequest) error
	Recv() (*EnterPodResponse, error)
	grpc.ClientStream
}

type publicWriteOnlyAPIEnterPodClient struct {
	grpc.ClientStream
}

func (x *publicWriteOnlyAPIEnterPodClient) Send(m *EnterPodRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *publicWriteOnlyAPIEnterPodClient) Recv() (*EnterPodResponse, error) {
	m := new(EnterPodResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for PublicWriteOnlyAPI service

type PublicWriteOnlyAPIServer interface {
	// FetchImage fetches a container image into the image store.
	FetchImage(context.Context, *FetchImageRequest) (*FetchImageResponse, error)
	// PreparePod prepares a pod, currently it only supports preparing from a pod manifest.
	PreparePod(context.Context, *PreparePodRequest) (*PreparePodResponse, error)
	// RemovePod removes a pod.
	RemovePod(context.Context, *RemovePodRequest) (*RemovePodResponse, error)
	// RemoveImage removes a container image from the image store.
	RemoveImage(context.Context, *RemoveImageRequest) (*RemoveImageResponse, error)
	// EnterPod enters the pod's namespace, it also returns a stream where the client can
	// read stdout and stderr.
	EnterPod(PublicWriteOnlyAPI_EnterPodServer) error
}

func RegisterPublicWriteOnlyAPIServer(s *grpc.Server, srv PublicWriteOnlyAPIServer) {
	s.RegisterService(&_PublicWriteOnlyAPI_serviceDesc, srv)
}

func _PublicWriteOnlyAPI_FetchImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(FetchImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(PublicWriteOnlyAPIServer).FetchImage(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _PublicWriteOnlyAPI_PreparePod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(PreparePodRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(PublicWriteOnlyAPIServer).PreparePod(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _PublicWriteOnlyAPI_RemovePod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RemovePodRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(PublicWriteOnlyAPIServer).RemovePod(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _PublicWriteOnlyAPI_RemoveImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RemoveImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(PublicWriteOnlyAPIServer).RemoveImage(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _PublicWriteOnlyAPI_EnterPod_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PublicWriteOnlyAPIServer).EnterPod(&publicWriteOnlyAPIEnterPodServer{stream})
}

type PublicWriteOnlyAPI_EnterPodServer interface {
	Send(*EnterPodResponse) error
	Recv() (*EnterPodRequest, error)
	grpc.ServerStream
}

type publicWriteOnlyAPIEnterPodServer struct {
	grpc.ServerStream
}

func (x *publicWriteOnlyAPIEnterPodServer) Send(m *EnterPodResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *publicWriteOnlyAPIEnterPodServer) Recv() (*EnterPodRequest, error) {
	m := new(EnterPodRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _PublicWriteOnlyAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "v1alpha.PublicWriteOnlyAPI",
	HandlerType: (*PublicWriteOnlyAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FetchImage",
			Handler:    _PublicWriteOnlyAPI_FetchImage_Handler,
		},
		{
			MethodName: "PreparePod",
			Handler:    _PublicWriteOnlyAPI_PreparePod_Handler,
		},
		{
			MethodName: "RemovePod",
			Handler:    _PublicWriteOnlyAPI_RemovePod_Handler,
		},
		{
			MethodName: "RemoveImage",
			Handler:    _PublicWriteOnlyAPI_RemoveImage_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "EnterPod",
			Handler:       _PublicWriteOnlyAPI_EnterPod_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
}

var fileDescriptor0 = []byte{
	// 1919 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x58, 0xcf, 0x52, 0xe3, 0xcc,
	0x11, 0xc7, 0xff, 0xed, 0x36, 0x6b, 0xcb, 0x02, 0x3e, 0x8c, 0x97, 0x8f, 0x0f, 0x94, 0x64, 0x6b,
	0x97, 0x03, 0xd9, 0xb0, 0x9b, 0xbd, 0xa4, 0x2a, 0xb5, 0x06, 0x0b, 0xe2, 0xc5, 0xd8, 0x2e, 0x63,
	0x36, 0xe1, 0xa4, 0x12, 0xf6, 0x18, 0x54, 0xc8, 0x96, 0x22, 0xc9, 0xec, 0x92, 0x63, 0x4e, 0xb9,
	0xe5, 0x11, 0xf2, 0x18, 0x79, 0x87, 0xdc, 0xf2, 0x0a, 0xa9, 0xca, 0x73, 0x24, 0x3d, 0xa3, 0x91,
	0x34, 0x92, 0xe5, 0x54, 0xa5, 0x8a, 0x03, 0xea, 0xee, 0xf9, 0xf5, 0xff, 0xee, 0xf1, 0x40, 0x45,
	0xb7, 0x8d, 0x13, 0xdb, 0xb1, 0x3c, 0x4b, 0x2e, 0x3d, 0xff, 0x4a, 0x37, 0xed, 0x47, 0x5d, 0xf9,
	0x67, 0x06, 0x1a, 0x17, 0xc4, 0x9b, 0x3c, 0x76, 0xe7, 0xfa, 0x03, 0x19, 0x91, 0x3f, 0x2e, 0x89,
	0xeb, 0xc9, 0xfb, 0x90, 0xf7, 0x5e, 0x6c, 0xd2, 0xcc, 0x1c, 0x66, 0xde, 0x56, 0x4f, 0x6b, 0x27,
	0x5c, 0xfa, 0x84, 0x09, 0xc9, 0x9b, 0x90, 0x5f, 0xe8, 0x73, 0xd2, 0xcc, 0x22, 0xb7, 0x22, 0xbf,
	0x87, 0xba, 0xb1, 0x70, 0xc9, 0x64, 0xe9, 0x10, 0xcd, 0xb2, 0x3d, 0xc3, 0x5a, 0x34, 0x73, 0xc8,
	0xa8, 0x9d, 0xee, 0x46, 0xc7, 0x38, 0x7f, 0xc0, 0xd8, 0xf4, 0xc4, 0xd4, 0x70, 0x27, 0xd6, 0x33,
	0x71, 0x82, 0x13, 0xf9, 0xc4, 0x89, 0x0e, 0xe7, 0xf3, 0x13, 0x0d, 0xa8, 0x7c, 0x33, 0xbc, 0x47,
	0x6d, 0x4a, 0x6c, 0xb7, 0x59, 0x40, 0xd9, 0xb2, 0xbc, 0x07, 0x8d, 0x89, 0x43, 0xa6, 0x64, 0xe1,
	0x19, 0xba, 0xe9, 0x6a, 0x13, 0x6b, 0x31, 0x7b, 0x68, 0x16, 0x91, 0xb5, 0xa9, 0x1c, 0x82, 0x2c,
	0xba, 0xe4, 0xda, 0x16, 0xea, 0x97, 0x01, 0xb2, 0xc6, 0x94, 0x79, 0x54, 0x51, 0xde, 0x41, 0x63,
	0xe8, 0x10, 0x5b, 0x77, 0xc8, 0xd0, 0x9a, 0x06, 0x4e, 0x6f, 0xc3, 0xa6, 0x6d, 0x4d, 0xb5, 0xb9,
	0xbe, 0x30, 0x66, 0xf8, 0xcd, 0x44, 0x19, 0x98, 0x28, 0x9a, 0x02, 0x76, 0x00, 0xd2, 0x88, 0xcc,
	0xd1, 0x5a, 0x01, 0x4b, 0xe4, 0x6f, 0x41, 0x43, 0xe0, 0xfb, 0x00, 0xca, 0x09, 0xc8, 0x3e, 0x31,
	0x16, 0x77, 0xe1, 0x58, 0x3c, 0xca, 0xca, 0x0e, 0x6c, 0xc5, 0xe4, 0x39, 0xcc, 0x00, 0xea, 0xea,
	0xc2, 0x23, 0x4e, 0xba, 0x6a, 0x59, 0x82, 0xb2, 0x6e, 0xdb, 0x9a, 0x90, 0xad, 0x3a, 0x94, 0x26,
	0xd6, 0x1c, 0x7d, 0x9c, 0x62, 0x96, 0x72, 0x48, 0x78, 0x05, 0x05, 0xd7, 0x9b, 0x1a, 0x7e, 0x0a,
	0x2a, 0xca, 0x29, 0x48, 0x11, 0x20, 0x77, 0xb6, 0x06, 0x45, 0x14, 0xb1, 0x96, 0x1e, 0x47, 0xf5,
	0xbf, 0x89, 0xe3, 0x70, 0xdb, 0x3e, 0x43, 0x95, 0x59, 0x75, 0x61, 0x39, 0x73, 0xdd, 0x93, 0x0f,
	0x85, 0xe2, 0xa9, 0x9d, 0xca, 0xf1, 0xe2, 0x19, 0x23, 0x87, 0x1a, 0x81, 0xb9, 0x75, 0x69, 0xe2,
	0x7d, 0x84, 0x7f, 0x65, 0xa0, 0xe0, 0xd7, 0xd6, 0x3b, 0xa8, 0xde, 0xeb, 0x2e, 0xd1, 0x66, 0x0c,
	0x8b, 0x17, 0xe0, 0x76, 0x1c, 0x83, 0xeb, 0xf1, 0x1d, 0xcd, 0xc6, 0x82, 0x95, 0x0b, 0x9c, 0x0c,
	0xf0, 0x99, 0x57, 0x72, 0x13, 0x24, 0x63, 0x6e, 0x5b, 0x8e, 0xa7, 0x79, 0xc6, 0x1c, 0x83, 0xa4,
	0xcf, 0x6d, 0x56, 0x46, 0x39, 0x1a, 0xa1, 0x30, 0xe1, 0xac, 0x7a, 0x28, 0x94, 0x6b, 0xfc, 0x89,
	0x34, 0x4b, 0x8c, 0xff, 0x06, 0xaa, 0xfa, 0x62, 0x61, 0x79, 0x3a, 0xad, 0x43, 0xb7, 0x59, 0xc6,
	0x98, 0x55, 0x4f, 0x1b, 0xa1, 0x3d, 0x57, 0xe4, 0xe5, 0xab, 0x6e, 0x2e, 0x89, 0x7c, 0x04, 0x45,
	0x53, 0xbf, 0x27, 0xa6, 0xdb, 0xac, 0xac, 0x11, 0x51, 0x3e, 0x40, 0xa9, 0x4f, 0xbc, 0x6f, 0x96,
	0xf3, 0x14, 0x9a, 0x1b, 0x66, 0xda, 0xb0, 0x9f, 0x3f, 0x46, 0xae, 0xe0, 0xd7, 0x27, 0xdf, 0x15,
	0xe5, 0xaf, 0x19, 0xc8, 0xb5, 0x6d, 0x3b, 0x71, 0xe2, 0x47, 0x28, 0x18, 0x34, 0x12, 0xec, 0xc8,
	0x6a, 0x83, 0x1e, 0xd2, 0x9c, 0xea, 0x1e, 0xe1, 0x8d, 0x18, 0xd9, 0x82, 0x48, 0x37, 0x94, 0x41,
	0x1b, 0x8a, 0x7c, 0x37, 0x3c, 0x6c, 0x9b, 0x29, 0x61, 0x31, 0x6a, 0x24, 0x3d, 0x2d, 0xac, 0x73,
	0xe3, 0x2f, 0x59, 0xc8, 0x61, 0x75, 0xc4, 0xea, 0xac, 0x0a, 0x39, 0x9b, 0xe7, 0xa2, 0xb1, 0x5e,
	0x3b, 0x9e, 0xf2, 0xb5, 0xb7, 0x20, 0x8f, 0x65, 0xe9, 0xa2, 0x62, 0xaa, 0x63, 0x53, 0x34, 0x4f,
	0x56, 0xa0, 0xbc, 0xf0, 0xa3, 0x14, 0xd8, 0x20, 0x85, 0xfc, 0x20, 0x7c, 0xab, 0x49, 0x4b, 0x18,
	0x5f, 0x5a, 0x97, 0x26, 0x2c, 0xdd, 0xc9, 0x83, 0x63, 0x2d, 0x6d, 0xcc, 0x24, 0x35, 0x1c, 0xbd,
	0xc0, 0x29, 0x82, 0x36, 0x4d, 0x35, 0xac, 0xb6, 0x0a, 0x4b, 0x39, 0xd2, 0xd0, 0x7e, 0x87, 0xd3,
	0x80, 0xd1, 0x70, 0x36, 0x3c, 0x4c, 0x70, 0x34, 0x38, 0x4f, 0x3e, 0xb5, 0x4a, 0xa9, 0xca, 0x1b,
	0x28, 0x87, 0xc8, 0x18, 0x02, 0xfc, 0x9f, 0xc7, 0x03, 0x9b, 0xea, 0x99, 0x52, 0x79, 0x79, 0xff,
	0x23, 0x03, 0x15, 0x74, 0xfe, 0xc2, 0x30, 0xb1, 0xb3, 0xa8, 0xa4, 0x31, 0x75, 0x51, 0x92, 0xb6,
	0xdf, 0x11, 0xed, 0x25, 0xd4, 0xef, 0xa2, 0x68, 0x2e, 0x3d, 0x5a, 0x0d, 0x3a, 0xb8, 0xfd, 0x26,
	0x76, 0x79, 0xd3, 0x22, 0x89, 0xe5, 0x5f, 0xa3, 0x40, 0x79, 0x46, 0xda, 0x81, 0x57, 0x3c, 0x6e,
	0x5c, 0xb2, 0xc0, 0xc8, 0x89, 0xc0, 0x14, 0xd7, 0x05, 0x86, 0xce, 0x05, 0x16, 0x18, 0x3f, 0x78,
	0x15, 0x79, 0x17, 0xea, 0x74, 0x1a, 0xba, 0xcb, 0x7b, 0x2d, 0x60, 0xd0, 0xe2, 0x67, 0xbd, 0xca,
	0xdb, 0x3d, 0xc5, 0x1d, 0xcc, 0x8c, 0xed, 0x90, 0x99, 0xf1, 0x9d, 0x3b, 0xc4, 0x22, 0xcc, 0x1a,
	0x5a, 0x34, 0x1f, 0xa5, 0x9e, 0xc8, 0x0b, 0xda, 0x1a, 0x5a, 0x1f, 0xb5, 0xcf, 0xba, 0xba, 0x93,
	0x7f, 0x80, 0x9a, 0xdf, 0xc3, 0x34, 0x03, 0x33, 0xd4, 0xcc, 0x52, 0x9f, 0xa3, 0x86, 0x86, 0xf4,
	0x7b, 0x82, 0x73, 0xe3, 0xff, 0x6d, 0x5d, 0xb4, 0x70, 0xb6, 0x34, 0x4d, 0x6e, 0x61, 0x85, 0x39,
	0xf9, 0x37, 0x74, 0xf2, 0xd2, 0xb4, 0xee, 0x75, 0xf3, 0xc2, 0xd4, 0x1f, 0x5c, 0xea, 0xe4, 0xd4,
	0x70, 0x78, 0x76, 0x71, 0xf5, 0xb8, 0x2f, 0xae, 0x47, 0xe6, 0x6c, 0xeb, 0x18, 0x0f, 0x1a, 0x65,
	0x65, 0x83, 0x41, 0x63, 0x5a, 0x13, 0xdd, 0x14, 0x39, 0xfe, 0x4c, 0x42, 0x33, 0x97, 0x2e, 0x2e,
	0x3c, 0x81, 0xe1, 0xcf, 0x26, 0xea, 0x57, 0xb0, 0x3f, 0x67, 0x54, 0x19, 0x9b, 0x4c, 0xb4, 0xc7,
	0x77, 0x3c, 0x67, 0xe9, 0x7a, 0x1a, 0x86, 0xca, 0xd5, 0x66, 0x8e, 0x35, 0xd7, 0x1e, 0x3d, 0xcf,
	0x76, 0x99, 0xdb, 0x65, 0xc5, 0x81, 0x7c, 0x77, 0x31, 0xb3, 0xe4, 0x2d, 0xa8, 0x3a, 0x4f, 0x9e,
	0x16, 0xcc, 0x3b, 0xdf, 0x42, 0x2c, 0x57, 0x2c, 0x99, 0x89, 0x16, 0x9b, 0xb2, 0x54, 0x14, 0x6f,
	0x00, 0x21, 0xd1, 0xb7, 0xeb, 0x18, 0x2b, 0x9b, 0x39, 0xca, 0x95, 0xe7, 0x13, 0x13, 0x57, 0x88,
	0x02, 0xea, 0x2c, 0xa8, 0xcf, 0xb8, 0x71, 0xd7, 0x8e, 0x78, 0xc6, 0x65, 0x23, 0x3e, 0x31, 0x9c,
	0xa9, 0xf9, 0x5c, 0x21, 0x7e, 0xd1, 0x21, 0xcc, 0x14, 0xe5, 0xe4, 0x9f, 0x20, 0x3f, 0xd5, 0x3d,
	0x7d, 0xfd, 0xb8, 0xf1, 0xa0, 0xca, 0x50, 0x79, 0xb5, 0x1d, 0x41, 0x81, 0x6a, 0xf6, 0xeb, 0x2d,
	0x5d, 0x35, 0x2f, 0xc8, 0x6c, 0xb0, 0xde, 0xc4, 0xca, 0xa3, 0xbd, 0x6d, 0x2c, 0x26, 0x44, 0x13,
	0x4c, 0x40, 0xda, 0x12, 0x6f, 0x11, 0xa6, 0x4f, 0x63, 0x6b, 0x41, 0x91, 0xa0, 0x76, 0x49, 0x3c,
	0x1a, 0x60, 0xbe, 0x56, 0x71, 0x61, 0xd7, 0x43, 0x0a, 0xdf, 0x8b, 0xaf, 0x71, 0x52, 0xe3, 0x37,
	0x5f, 0x52, 0xaf, 0x84, 0xeb, 0xce, 0xcc, 0x52, 0x2e, 0xa0, 0xde, 0x33, 0x5c, 0x0f, 0xbb, 0xd8,
	0x0d, 0x36, 0xf3, 0xcf, 0xa0, 0x34, 0x63, 0x5e, 0xf8, 0xd6, 0x57, 0x05, 0xeb, 0xa3, 0xe9, 0x80,
	0x13, 0x6a, 0x4a, 0x3c, 0xdd, 0x30, 0x59, 0xf0, 0xca, 0xa8, 0x57, 0x8a, 0x70, 0xb8, 0x62, 0x9c,
	0x9f, 0xd8, 0x9b, 0x01, 0xca, 0xa6, 0x88, 0xa2, 0xfc, 0x04, 0x0d, 0xbc, 0x6e, 0xd9, 0x64, 0xe2,
	0xad, 0xb9, 0x8e, 0xfc, 0x12, 0x64, 0x51, 0x80, 0x43, 0xee, 0xe1, 0x04, 0xb7, 0xa6, 0xdc, 0x95,
	0x38, 0xe2, 0x17, 0x68, 0x50, 0x0b, 0x58, 0xcf, 0x87, 0xbe, 0xfc, 0x22, 0xe9, 0x4b, 0x72, 0x47,
	0xa7, 0x7b, 0xf3, 0x11, 0x64, 0x11, 0x8b, 0x2b, 0x3f, 0x80, 0x22, 0x1b, 0x67, 0x01, 0x56, 0x62,
	0x9f, 0x29, 0x47, 0xb0, 0xc5, 0x4d, 0x5e, 0x77, 0x5b, 0x52, 0x7e, 0x0d, 0xdb, 0x71, 0x11, 0x0e,
	0x1d, 0x6e, 0xca, 0xd4, 0xab, 0xac, 0xf2, 0x1b, 0xd8, 0xa2, 0xf6, 0x90, 0x05, 0x2b, 0x9f, 0xd0,
	0xbb, 0x9f, 0x43, 0xd1, 0xf7, 0x6e, 0xe5, 0x02, 0x22, 0xd4, 0xa2, 0xf2, 0x09, 0xb6, 0xe3, 0x87,
	0x23, 0x77, 0x08, 0xa3, 0xac, 0xb8, 0xc3, 0x04, 0x95, 0x17, 0x56, 0x5c, 0x3d, 0xeb, 0x21, 0xd4,
	0x87, 0x61, 0xa2, 0xc3, 0xf6, 0x7f, 0xdc, 0xdb, 0xb0, 0x8e, 0x4d, 0x63, 0xc1, 0xea, 0x38, 0xf3,
	0xb6, 0x40, 0x0f, 0xcc, 0x2c, 0xd3, 0xb4, 0xbe, 0xb1, 0x1a, 0x2e, 0x27, 0xea, 0xba, 0x90, 0x52,
	0xd7, 0x6c, 0x58, 0xe2, 0x6d, 0xb6, 0x1e, 0xaa, 0xe6, 0xd6, 0x86, 0xc8, 0x6c, 0x82, 0x1f, 0x13,
	0xa8, 0x44, 0x17, 0xb5, 0x26, 0x46, 0xf5, 0xba, 0x7d, 0xa9, 0x6a, 0xe3, 0xbb, 0xa1, 0xaa, 0xdd,
	0xf6, 0x3b, 0xea, 0x45, 0xb7, 0xaf, 0x76, 0xa4, 0x0d, 0x9c, 0x25, 0x75, 0x81, 0xd3, 0x1e, 0x0e,
	0xcf, 0xa5, 0x0c, 0xee, 0xa0, 0x86, 0x40, 0xec, 0x0c, 0xce, 0xaf, 0xd4, 0x91, 0x94, 0x45, 0x43,
	0x6a, 0x02, 0x79, 0x70, 0xde, 0x95, 0x72, 0xc7, 0xb8, 0x12, 0x6b, 0x89, 0x9f, 0x05, 0x54, 0x59,
	0xff, 0x46, 0x3d, 0xbf, 0x1d, 0xa1, 0xd0, 0x70, 0xdc, 0x1d, 0xf4, 0xb5, 0xfe, 0xa0, 0xaf, 0xa2,
	0xb2, 0x5d, 0xcc, 0x7f, 0x82, 0xd3, 0xee, 0xf5, 0x50, 0xe1, 0x1e, 0xec, 0x24, 0x19, 0x4c, 0x13,
	0x2a, 0x4d, 0x39, 0x33, 0xee, 0xdd, 0x48, 0x79, 0xec, 0xda, 0xdd, 0x24, 0x03, 0xff, 0x3a, 0xdd,
	0x9b, 0x2b, 0xa9, 0x9c, 0x66, 0xc3, 0xef, 0xc6, 0xe3, 0xa1, 0x24, 0x61, 0xcf, 0xfd, 0x90, 0xe4,
	0x0c, 0x6f, 0xcf, 0xae, 0xd4, 0x3b, 0xe9, 0xf0, 0xf8, 0x11, 0x6a, 0x89, 0x1f, 0x2c, 0x88, 0x83,
	0x88, 0xe7, 0x83, 0xaf, 0xea, 0x28, 0xe1, 0xcb, 0x3e, 0x34, 0x57, 0x39, 0xda, 0xcd, 0x78, 0x30,
	0x52, 0xd1, 0xa1, 0x03, 0x68, 0x25, 0xb9, 0x83, 0x7e, 0xef, 0x8e, 0xf3, 0xb3, 0xc7, 0x43, 0x28,
	0x87, 0x77, 0x38, 0xf4, 0x10, 0xe3, 0x8e, 0xac, 0xf6, 0x38, 0x9e, 0x1b, 0x4c, 0x43, 0xc4, 0x18,
	0xdd, 0xf6, 0xfb, 0xdd, 0xfe, 0x25, 0x62, 0x6f, 0x83, 0x14, 0x91, 0xd5, 0x3f, 0x74, 0xc7, 0x28,
	0x9c, 0x3d, 0xfe, 0x77, 0x06, 0xca, 0xe1, 0x55, 0x03, 0x21, 0x87, 0x83, 0x4e, 0x0a, 0x24, 0x9e,
	0x8d, 0x18, 0xea, 0xf5, 0xd9, 0xe8, 0x6e, 0x80, 0x88, 0x31, 0xf1, 0xe1, 0x48, 0x1d, 0xb6, 0x47,
	0x54, 0x55, 0x16, 0x77, 0x9a, 0x9c, 0x64, 0x20, 0x4c, 0x8e, 0x5a, 0x16, 0xd1, 0x03, 0xcb, 0xf2,
	0xd8, 0xa4, 0x7b, 0x11, 0xb9, 0x7d, 0x36, 0x18, 0xa1, 0x69, 0xc1, 0x31, 0xa9, 0x90, 0x50, 0xee,
	0x1b, 0x5e, 0x8c, 0xeb, 0xe8, 0xa8, 0x3d, 0x75, 0x4c, 0xc1, 0x4a, 0x71, 0x1d, 0x97, 0xed, 0xd1,
	0x19, 0xad, 0x87, 0xf2, 0xf1, 0xdf, 0xb3, 0x50, 0x89, 0x76, 0x04, 0xe6, 0x47, 0xfd, 0xaa, 0xf6,
	0xc7, 0xab, 0x85, 0x8d, 0xe5, 0x21, 0x70, 0x28, 0x52, 0x68, 0x7f, 0x06, 0x2f, 0xa7, 0x07, 0xe9,
	0xcc, 0xc0, 0x6a, 0xf4, 0x1d, 0x0b, 0x25, 0x21, 0x83, 0xa6, 0x30, 0x5e, 0x8e, 0xd6, 0x6b, 0x82,
	0xc7, 0xdd, 0xc9, 0xe3, 0xc8, 0x39, 0x4c, 0xb0, 0xb8, 0xed, 0xda, 0xf9, 0xa0, 0xd7, 0x53, 0xcf,
	0xa9, 0x54, 0x21, 0x01, 0xce, 0xd3, 0x39, 0xf2, 0x03, 0x12, 0x07, 0xa7, 0x3c, 0x0e, 0x5e, 0xa2,
	0x01, 0x16, 0x58, 0x7e, 0x33, 0x76, 0xaf, 0x87, 0xbe, 0xc9, 0x65, 0x5a, 0x93, 0x2b, 0xec, 0x91,
	0x7a, 0x8d, 0x55, 0xd8, 0x91, 0x2a, 0xa7, 0x7f, 0xce, 0xe3, 0xed, 0x75, 0x79, 0x6f, 0x1a, 0x93,
	0xf6, 0xb0, 0x2b, 0xff, 0x16, 0x4a, 0x7c, 0x0f, 0xca, 0xd1, 0xcf, 0xf5, 0xf8, 0xae, 0x6c, 0x35,
	0x57, 0x19, 0xfc, 0xf7, 0xea, 0x86, 0xdc, 0x86, 0x72, 0xb0, 0xcf, 0xe4, 0x48, 0x2e, 0xb1, 0x2a,
	0x5b, 0x7b, 0x29, 0x9c, 0x10, 0xe2, 0x12, 0x20, 0xda, 0x60, 0x72, 0x4b, 0x7c, 0x66, 0x88, 0xef,
	0xbd, 0xd6, 0xeb, 0x54, 0x9e, 0x08, 0x14, 0x6d, 0x23, 0x01, 0x68, 0x65, 0xdd, 0x09, 0x40, 0xab,
	0xeb, 0x0b, 0x81, 0xae, 0x61, 0x53, 0xdc, 0x3e, 0xf2, 0x7e, 0x52, 0xaf, 0xb8, 0xb7, 0x5a, 0x3f,
	0xae, 0xe1, 0x86, 0x70, 0x03, 0xd8, 0x14, 0x17, 0x8b, 0x00, 0x97, 0xb2, 0xac, 0x04, 0xb8, 0xb4,
	0x6d, 0xa4, 0x6c, 0xbc, 0xcf, 0xc8, 0x9f, 0x59, 0xd2, 0xe8, 0xd8, 0x8f, 0x27, 0x4d, 0xd8, 0x41,
	0xf1, 0xa4, 0x89, 0x1b, 0x82, 0x22, 0x9c, 0xfe, 0x27, 0x8b, 0xed, 0xc6, 0x8a, 0xe0, 0xf7, 0x8e,
	0xe1, 0x91, 0xc1, 0xc2, 0x7c, 0xa1, 0xd5, 0x80, 0x11, 0x8c, 0x9e, 0x5a, 0x84, 0x08, 0xae, 0x3c,
	0x29, 0x09, 0x11, 0x5c, 0x7d, 0x9b, 0xf1, 0x53, 0x11, 0x3d, 0xb3, 0x08, 0x40, 0x2b, 0xcf, 0x34,
	0x02, 0xd0, 0xea, 0xbb, 0x0c, 0x02, 0x75, 0xa0, 0x12, 0xbe, 0xb6, 0xc8, 0x51, 0x19, 0x25, 0x5f,
	0x68, 0x5a, 0xad, 0x34, 0x56, 0x88, 0xf2, 0x05, 0xaa, 0xc2, 0x73, 0x8b, 0xfc, 0x3a, 0x21, 0x1c,
	0xf3, 0x6c, 0x3f, 0x9d, 0x19, 0x62, 0xa9, 0x50, 0x0e, 0x9e, 0x54, 0x84, 0x8a, 0x4f, 0x3c, 0xdb,
	0x08, 0x15, 0x9f, 0x7c, 0x7f, 0x51, 0x36, 0xde, 0x66, 0xde, 0x67, 0xee, 0x8b, 0xec, 0xe5, 0xee,
	0xc3, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xed, 0xdc, 0x2e, 0xb4, 0xc6, 0x13, 0x00, 0x00,
}
